#!/usr/bin/env python3
"""
Standalone AST Visualizer for Tree-sitter Parse Trees

This script provides a command-line interface for visualizing C/C++ AST trees
generated by tree-sitter. It can output in various formats including:
- Console text output
- JSON format for programmatic analysis
- Text file output

Usage:
    python ast_visualizer_standalone.py file.cpp --console
    python ast_visualizer_standalone.py file.cpp -o ast_output --format txt
    python ast_visualizer_standalone.py file.cpp -o ast_output --format json
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Dict, Any, Optional

# Import tree-sitter dependencies
try:
    import tree_sitter_cpp as tscpp
    from tree_sitter import Language, Parser, Node
    TREESITTER_AVAILABLE = True
except ImportError:
    TREESITTER_AVAILABLE = False

class ASTVisualizer:
    """AST visualization utilities for tree-sitter parse trees."""
    
    def __init__(self):
        self.node_counter = 0
        self.node_ids = {}  # Map node objects to unique IDs
        
    def _get_node_id(self, node: Node) -> str:
        """Get or create a unique ID for a node."""
        if id(node) not in self.node_ids:
            self.node_ids[id(node)] = f"node_{self.node_counter}"
            self.node_counter += 1
        return self.node_ids[id(node)]
    
    def _get_node_text(self, node: Node, source_code: str) -> str:
        """Get the text content of a node."""
        return source_code[node.start_byte:node.end_byte]
    
    def print_tree_text(self, node: Node, source_code: str, indent: str = "", max_depth: int = 10, current_depth: int = 0):
        """Print tree structure in text format to console."""
        if current_depth > max_depth:
            print(f"{indent}... (max depth {max_depth} reached)")
            return
            
        # Get node text (truncated for readability)
        node_text = self._get_node_text(node, source_code).strip()
        if len(node_text) > 60:
            node_text = node_text[:57] + "..."
        
        # Replace newlines for cleaner output
        node_text = node_text.replace('\n', '\\n').replace('\r', '\\r')
        
        # Print current node
        print(f"{indent}├─ {node.type}")
        if node_text and node.type not in ['translation_unit', 'compound_statement']:
            print(f"{indent}│  └─ \"{node_text}\"")
        
        # Print children
        for i, child in enumerate(node.children):
            is_last = (i == len(node.children) - 1)
            child_indent = indent + ("   " if is_last else "│  ")
            self.print_tree_text(child, source_code, child_indent, max_depth, current_depth + 1)
    
    def to_json(self, node: Node, source_code: str, max_depth: int = 10) -> Dict[str, Any]:
        """Convert AST to JSON format."""
        def node_to_dict(node: Node, depth: int = 0) -> Dict[str, Any]:
            if depth > max_depth:
                return {"type": node.type, "text": "... (max depth reached)"}
            
            node_dict = {
                "type": node.type,
                "start_byte": node.start_byte,
                "end_byte": node.end_byte,
                "start_point": [node.start_point.row, node.start_point.column],
                "end_point": [node.end_point.row, node.end_point.column]
            }
            
            # Add text content for leaf nodes
            if not node.children:
                node_text = self._get_node_text(node, source_code).strip()
                if node_text:
                    node_dict["text"] = node_text
            
            # Add children
            if node.children:
                node_dict["children"] = [node_to_dict(child, depth + 1) for child in node.children]
            
            return node_dict
        
        return node_to_dict(node)
    
    def save_visualization(self, node: Node, source_code: str, output_path: str,
                          format_type: str = "txt", max_depth: int = 8, title: str = "AST Tree"):
        """Save AST visualization to file."""
        if format_type == "txt":
            # Save text representation
            with open(f"{output_path}.txt", 'w', encoding='utf-8') as f:
                import io
                import contextlib
                
                # Capture print output
                f_stdout = io.StringIO()
                with contextlib.redirect_stdout(f_stdout):
                    self.print_tree_text(node, source_code, max_depth=max_depth)
                
                f.write(f"AST Tree: {title}\n")
                f.write("=" * 60 + "\n")
                f.write(f_stdout.getvalue())
            
            print(f"AST saved as text: {output_path}.txt")
            
        elif format_type == "json":
            # Save JSON representation
            ast_dict = self.to_json(node, source_code, max_depth)
            with open(f"{output_path}.json", 'w', encoding='utf-8') as f:
                json.dump(ast_dict, f, indent=2, ensure_ascii=False)
            
            print(f"AST saved as JSON: {output_path}.json")
            
        else:
            # Unsupported format
            print(f"Error: Unsupported format '{format_type}'. Supported formats: txt, json")
            return


def parse_file_with_treesitter(file_path: str) -> tuple:
    """Parse a C/C++ file using tree-sitter."""
    # Set up parser
    language = Language(tscpp.language())
    parser = Parser(language)
    
    # Read and parse file
    with open(file_path, 'r', encoding='utf-8') as f:
        source_code = f.read()
    
    tree = parser.parse(bytes(source_code, 'utf-8'))
    return tree.root_node, source_code


def main():
    """Command line interface for AST visualization."""
    if not TREESITTER_AVAILABLE:
        print("Error: Required dependencies not found.")
        print("Please install: pip install tree-sitter tree-sitter-cpp")
        sys.exit(1)
    
    parser = argparse.ArgumentParser(
        description='Visualize Tree-sitter AST trees for C/C++ files',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s file.cpp --console                    # Print to console
  %(prog)s file.cpp -o ast_tree                  # Save as text file
  %(prog)s file.cpp -o ast_tree --format json    # Save as JSON
  %(prog)s file.cpp --console --depth 5          # Limit depth to 5 levels
        """
    )
    
    parser.add_argument('input_file', help='Input C/C++ source file to parse')
    parser.add_argument('-o', '--output', help='Output file path (without extension)')
    parser.add_argument('-f', '--format', choices=['txt', 'json'], 
                       default='txt', help='Output format (default: txt)')
    parser.add_argument('-d', '--depth', type=int, default=8, 
                       help='Maximum tree depth to visualize (default: 8)')
    parser.add_argument('--console', action='store_true', 
                       help='Print tree to console instead of saving file')
    parser.add_argument('--title', type=str, help='Custom title for the visualization')
    
    args = parser.parse_args()
    
    # Validate input file
    input_path = Path(args.input_file)
    if not input_path.exists():
        print(f"Error: Input file '{args.input_file}' not found")
        sys.exit(1)
    
    if input_path.suffix.lower() not in ['.c', '.cpp', '.cc', '.cxx', '.h', '.hpp']:
        print(f"Warning: '{args.input_file}' may not be a C/C++ file")
    
    try:
        # Parse the file
        print(f"Parsing file: {args.input_file}")
        root_node, source_code = parse_file_with_treesitter(args.input_file)
        
        # Create visualizer
        visualizer = ASTVisualizer()
        
        if args.console:
            # Print to console
            title = args.title or f"AST Tree: {input_path.name}"
            print(f"\n{title}")
            print("=" * len(title))
            print(f"Max depth: {args.depth}")
            print("-" * len(title))
            visualizer.print_tree_text(root_node, source_code, max_depth=args.depth)
        else:
            # Save to file
            if not args.output:
                args.output = str(input_path.with_suffix(''))
            
            title = args.title or f"AST Tree: {input_path.name}"
            visualizer.save_visualization(
                root_node, source_code, args.output, args.format, args.depth, title
            )
        
        print(f"\n✅ AST visualization completed successfully")
        
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
